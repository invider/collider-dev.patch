name: Pong
tags: start,begin,beginner,tutor,tutorial,sample,example,excercise,code,intro,arcade

== Intro

Pong was created in 1972 by Allan Alcorn, the 2nd non-founding employee of Atari, as an exercise. Nolan Bushnell, the Atari co-founder, reasoned that an electronic version of ping-pong will be a perfect way to get familiar with arcade game development. Especially considering that a similar concept had already been implemented in Magnavox Odyssey. 

Little did they know, that Pong would become a booster that brought Atari into a multi-billion corporation orbit.

Today, Pong is considered to be an arcade classic.

Also, with its iconic gameplay, it still works as a good exercise in game development.

Thus, this tutorial covers all the steps necessary to implement a web-based clone of Pong with Collider.JAM and JavaScript.

== Core Concepts

We need at least 3 components to implement
a viable Pong version:

* a puck moved by its speed vector
* two paddles controlled by players
* a score counter

There is also an invisible, but nevertheless present,
simple physics simulation to detect the puck
collisions with the paddles and the edges.

The game scene is going to be represented by a single *mod*.

_
> Collider.JAM has the concept of *mods*, which can represent
> modules, plugins, scenes, levels, game layers, and game states among other things.
> You can view a *mod* as a minigame with its own code,
> structure, resources...
> Like the main menu, or a player configuration screen,
> or maybe a map screen.
> Usually the *mod* structure is determined
> by the corresponding directory.
> A *mod* has it's own *dna*, *lab*, *trap* and other folders.
_


Inside, we will place the */dna* folder to keep our prototypes.

There are going to be only two of those - Puck and Paddle.

A single object in */lab/score.js* will represent the score.


The */res* folder will keep all sound effects. We won't need any bitmap or vector graphic resources in this tutorial, since everything will be drawn in code.

> Note, that file location and name are important for Collider.JAM.
>
> For example, there won't be any score if *score.js*
> will be placed outside of */lab*.
> Because objects in */lab* are "alive".
>
> Puck and Paddle MUST be placed in */dna* for similar reason.
> Constructors and factories are expected to be in */dna*.


== Foundation

Create a folder named _pong.mod_.
The _.mod_ extension is necessary for Collider.JAM
to determine the root of the project.


Once created, you can _cd_ into it:

    cd pong.mod

And run the empty mod with:

    jam -d

The _-d_ flag tells collider to enable development and debug features.

It is very useful in developing.

_
> Make sure you have [Collider.JAM](http://colliderlabs.com/jam) installed
> before starting this tutorial.
> The easiest way is to run "npm i -g collider.jam"
> in a terminal emulator.
>
> Collider.JAM makes all kind of JavaScript magic
> to remove the boilerplate code and make development
> as simple as possible.
_



== Puck

This prototype is located in _/dna/Puck.js_ and implements the puck behavior and visuals.


=== defaults

Let's declare some constants and default values:
```
// dna/Puck.js

#include::../demo/pong-ce.mod/dna/Puck.js | sed -n '/const MAX_SPEED/,/class Puck/p' | head -n -2
```


=== constructor

We'll use _class_ syntax to declare our prototype.
It's concise and works well except for a few special cases.
```
#include::../demo/pong-ce.mod/dna/Puck.js | sed -n '/class Puck/,/evo/p' | head -n -2
#include::../demo/pong-ce.mod/dna/Puck.js | tail -n 1
```
The _augment()_ function is provided by Collider.JAM and augments the target object with values from source objects.

We assign default values from *df* first and init values form *st* later (so init values can override the default ones).
It is a common idiom in Collider.JAM object initialization - declare an object with default values, pass an object with init values, and then augment the constructed object.


=== behavior

The puck needs the _evo(dt)_ function to determine its behavior and the _draw()_ function to define its look.

The _evo(dt)_ is the most complex one:
```
#include::../demo/pong-ce.mod/dna/Puck.js | sed -n '/evo/,/draw/p' | head -n -2
```

First, we need two guards to prevent evolution from happening while the game countdown is still on or we are holding the puck.
If the countdown value in _lab.score_ object is anything, but 0, we skip the evolution. We let the _score_ object itself handle the countdown behavior.

The _hold_ value tracks the time left to keep the puck frozen - we don't want to launch the puck the moment it's created. We have to reduce the timer until it's 0 or less, then we play a sound effect and the puck evolution begins.

The evolution itself has two main components - movement and collision detection.

We preserve coordinates before the movement to jump back in case of collision. That way we can prevent the tunnel effect through the edges and paddles. It is a crude and not exactly precise approach, but it works fine in our case.

The collision detection itself is split into two phases - collision with the edges and collision with the paddles.

The edge collision is handled by Puck locally. Notice the difference between the left/right and the top/bottom edges. For the top and the bottom edge we have to reflect the puck vector over the Y-axis:

     this.dy *= -1

and play the _boing_ sound effect.

In the case of the left or the right edge, we kill the puck and score the corresponding side. The _score_ logic is moved out into an external trap. It is a game-level event and it is a good practice to keep it in a separate function instead of being hidden in Puck.

The collision detection with paddles is different since it is handled mostly by the paddles.

We iterate over all nodes in _/lab_ and find the ones with *touch* (we assume that *touch()* will be a function here). The *touch()* function will be defined on all entities the puck can touch (paddles).

When the paddle hit is detected, we raise the _touched_ flag and increase the speed. The puck movement vector reflection is done in the paddle itself since it depends on the place on the paddle we hit.


=== rendering

The _draw()_ procedures of Puck are pretty simple - we just have to draw a circle.

```
#include::../demo/pong-ce.mod/dna/Puck.js | sed -n '/draw/,/}/p'
```
To setup the drawing, we set the line width and the stroke color.
And then call _circle_ function to draw the circle.



== Paddle

This *class* represents the left and the right paddles.

Its _draw()_ and _evo(dt)_ functions are quite simple.

The _touch()_ method is the most complex one and handles the collision detection with the puck. It is also responsible for the puck movement vector reflection according to the _REFLECT_VECTORS_ table.

```
// dna/Paddle.js
#include::../demo/pong-ce.mod/dna/Paddle.js
```



== Control

Keys are traped by the following 2 functions:

```
// trap/keyDown.js
#include::../demo/pong-ce.mod/trap/keyDown.js
```
```
// trap/keyUp.js
#include::../demo/pong-ce.mod/trap/keyUp.js
```
We raise movement flags in _keyDown()_ and reset them in _keyUp()_.



== Game Events


=== new game

The _"new game"_ event is traped by:
```
// trap/newGame.js
#include::../demo/pong-ce.mod/trap/newGame.js
```
Here we do all initial setup and spawning. It is trapped by _setup.js_ when the game starts and also by pressing the Escape key.


=== score

The following trap counts the score:
```
// trap/score.js
#include::../demo/pong-ce.mod/trap/score.js
```


== spawn puck

_spawnPuck_ creates a new Puck in _/lab_:


```
// trap/spawnPuck.js
#include::../demo/pong-ce.mod/trap/spawnPuck.js
```



== Setup

_setup.js_ contains the function to run just before the game starts:

```
#include::../demo/pong-ce.mod/setup.js
```
It just traps the new game.



== Source Code


Full source code is
[available on GitHub](https://github.com/invider/pong-ce.mod).



== Ideas for Improvement

There are multiple directions you can go from here.

You can introduce more variety into the gameplay by providing some kind of random powerups to modify game properties - like increase paddle speed or size, slow down the puck, etc...


You can improve visuals by adding bitmapped graphics or particle effects on collisions.


You can implement simple AI to be able to play against a computer.


You can add the ability to play over the network.


There might be other interesting ideas waiting to be implemented. Even the old and familiar gameplay from Pong can be rethought and refreshed.


== Summary

Collider.JAM makes a good job of hiding complexity
and free you from the boilerplate.

You don't see any imports, exports, load calls to get resources or extend constructions to inherit any of the framework prototypes.

You just name the functions and place the files in appropriate folders according to Collider.JAM conventions. And everything is just magically mixed together.

That is the magic of Collider.JAM!

Also notice how straightforward drawing and other common operations like _sin()_, _cos()_, _trap()_, _augment()_, and _kill()_. They are just functions available from the global context. No need to access those features from the bunch of incomprehensive utility objects like Context and Math. They are just there under your tips when you need them.

It makes JavaScript almost as clear and straightforward as BASIC. The code looks like a polite conversation with the framework instead of a rude arguing with the object system.











